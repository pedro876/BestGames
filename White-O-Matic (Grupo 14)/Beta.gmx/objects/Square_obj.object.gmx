<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Square_spr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Gamepad
gamepad_set_axis_deadzone(0, 0.3);
gamepad_set_axis_deadzone(4, 0.3); // Establece una fuerza minima que hay que ejercer al joystick para que responda
//Seed
randomize();
//Component y
Vy=0;
Vyaux=Vy;
ScrollDownVy=4.5;
VyMax=30;
ay=0.9;
Scroll=false;
//Component x
Vx=0;
Vxaux=Vx;
VxMax=10;
ax=2;
TurboVx=1.5;
A=false;
D=false;
//Jump
JumpVy=-20.5;
WallJumpVy=-26;
WallJumpVx=10;
WallJump=false;
Bounce=31;
Bouncing=false;
delay=0;
maxdelay=4;
//Controladores
alive = true;
shift_pressed=false;
deathTime=60;
//Fire
Burn=false;
Division=12;//aumento de j
BurnTime=0;
MaxBurnTime=4*60;
ParticlesPerStep=1;
//water
water=false;
cteWaterX=5;
cteWaterY=15;
cteWaterJump=5;
valueWaterY=1;
valueWaterX=1;
valueWaterJump=1;
posWater=0;
waterQuality=64;
//Eyes
instance_create(6,6, Eyes_obj);//Ojos Personaje
VxE=0;
VyE=0;
EAC=1.2;//Eyes Aceleration Constant
EyesLimit=7;
//Shader
instance_create(x,y,SquareShader_obj);
instance_create(0,0,GameManager);
//Original Position
Xo=x;
Yo=y;
//Complete level
completed=false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//instance_destroy(particle_obj);
//Component y
Vy=0;
//ScrollDownVy=4.5;
//VyMax=30;
//ay=0.9;
Scroll=false;
//Component x
Vx=0;
//VxMax=10;
//ax=2;
//TurboVx=1.5;
A=false;
D=false;
//Jump
//JumpVy=-20.5;
//WallJumpVy=-24.5;
//WallJumpVx=9;
WallJump=false;
//Bounce=31;
Bouncing=false;
delay=0;
maxdelay=4;
//Controladores
alive = true;
shift_pressed=false;
//deathTime=60;
//Fire
Burn=false;
//Division=12;//aumento de j
BurnTime=0;
//MaxBurnTime=3*60;
//ParticlesPerStep=1;
//water
water=false;
//cteWaterX=5;
//cteWaterY=15;
//cteWaterJump=5;
valueWaterY=1;
valueWaterX=1;
valueWaterJump=1;
posWater=0;
//waterQuality=64;
//Eyes
instance_create(6,6, Eyes_obj);//Ojos Personaje
VxE=0;
VyE=0;
//EAC=1.2;//Eyes Aceleration Constant
//Shader
instance_create(x,y,SquareShader_obj);
x=Xo;
y=Yo;
image_alpha=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(alive){
//Keys
Key_A = keyboard_check(ord("A")) || (gamepad_button_check(0, gp_padl)) || (gamepad_button_check(4, gp_padl)) || (gamepad_axis_value(0, gp_axislh) &lt; 0) || (gamepad_axis_value(4, gp_axislh) &lt; 0) || keyboard_check(vk_left) &amp;&amp; !completed; // Variable boolean para el moviemiento hacia la izquierda
Key_D = keyboard_check(ord("D")) || (gamepad_button_check(0, gp_padr)) || (gamepad_button_check(4, gp_padr)) || (gamepad_axis_value(0, gp_axislh) &gt; 0) || (gamepad_axis_value(4, gp_axislh) &gt; 0) || keyboard_check(vk_right) &amp;&amp; !completed; // Variable boolean para el moviemiento hacia la derecha
Key_Space = keyboard_check_pressed(vk_space) || gamepad_button_check_pressed(0, gp_face1) || gamepad_button_check_pressed(4, gp_face2) &amp;&amp; !completed; // Variable boolean para saltar
Key_Shift = keyboard_check(vk_shift) || gamepad_button_check(0, gp_shoulderrb) || gamepad_button_check(4, gp_shoulderrb) || gamepad_button_check(0, gp_shoulderlb) || gamepad_button_check(4, gp_shoulderlb) &amp;&amp; !completed; //Variable boolean para correr
//COMPONENTE Y
if (!place_meeting(x, y + 1, C_obj) &amp;&amp; !place_meeting(x,y+1,Bounce_obj) &amp;&amp; !Scroll) { //Gravedad
    Vy = Vy + ay/valueWaterY;
    if (Vy &gt; VyMax/valueWaterY) {
        Vy = VyMax/valueWaterY;
    }
}
//Componente X
if(!completed){//SI NO HE COMPLETADO EL NIVEL ME PUEDO MOVER
if (!Key_A) {
    A = false;
}
if (!Key_D) {
    D = false;
}
if (WallJump) { //Si estoy haciendo WallJump y pulso alguna tecla de movimeinto la variable WallJump pasa a ser falsa para que te muevas según físicas normales
    if (Key_A || Key_D) {
        WallJump = false;
    }
}
if(Scroll &amp;&amp; !Key_A &amp;&amp; !Key_D){ //Si estoy en la pared y no pulso teclas de movimiento el delay se reinicia
    delay=0;
}
if (Key_A &amp;&amp; !D) { //Movimiento hacia la izquierda
    if((place_meeting(x-1,y,C_obj)||place_meeting(x-1,y,Bounce_obj)) || ((place_meeting(x+1,y,C_obj) || place_meeting(x+1,y,Bounce_obj))&amp;&amp;(delay&lt;maxdelay)&amp;&amp;!(place_meeting(x,y+1,C_obj) || place_meeting(x,y+1,Bounce_obj)))){ //Si toco pared o Bounce por la izquierda o derecha, el delay no ha terminado y no tengo suelo debajo
        if ((place_meeting(x - 1, y, C_obj) || place_meeting(x - 1, y, Bounce_obj)) &amp;&amp; !(place_meeting(x, y+1, C_obj) || place_meeting(x, y+1, Bounce_obj)) &amp;&amp; !Scroll &amp;&amp; !place_meeting(x,y,water_obj)) { //Si toco pared a la izquierda y no toco suelo ni hago scroll ni toco agua
            A = true;
            Vx = Vx - ax/valueWaterX;
            if (!Key_Shift) { //Sin turbo
                if (Vx &lt; (-VxMax)/valueWaterX) {
                    Vx = -VxMax/valueWaterX;
                }
            } else if (Key_Shift) { //Con turbo
                Vx = Vx - ax/valueWaterX;
                if (Vx &lt; (-(VxMax * TurboVx))/valueWaterX) {
                    Vx = -(VxMax * TurboVx)/valueWaterX;
                }
            }
        } else if((place_meeting(x+1,y,C_obj) || place_meeting(x+1,y,Bounce_obj)) &amp;&amp; Scroll){ //Si me muevo a la izquierda y estoy haciendo scroll a la derecha
            delay=delay+1;
            if (delay&gt;maxdelay){
                delay=maxdelay;
            }
        } else if ((place_meeting(x+1,y,C_obj) || place_meeting(x+1,y,Bounce_obj)) &amp;&amp; !Scroll){ //Si me muevo a la izquierda y NO estoy haciendo scroll a la derecha{
            A=true;
            Vx = Vx - ax/valueWaterX;
            if (!Key_Shift) { //Sin turbo
                if (Vx &lt; (-VxMax)/valueWaterX) {
                    Vx = -VxMax/valueWaterX;
                }
            } else if (Key_Shift) { //Con turbo
                Vx = Vx - ax/valueWaterX;
                if (Vx &lt; (-(VxMax * TurboVx))/valueWaterX) {
                    Vx = -(VxMax * TurboVx)/valueWaterX;
                }
            }
        }
    } else {
        delay=0;
        A = true;
        Vx = Vx - ax/valueWaterX;
        if (!Key_Shift) { //Sin turbo
            if (Vx &lt; (-VxMax)/valueWaterX) {
                Vx = -VxMax/valueWaterX;
            }
        } else if (Key_Shift) { //Con turbo
            Vx = Vx - ax/valueWaterX;
            if (Vx &lt; (-(VxMax * TurboVx))/valueWaterX) {
                Vx = -(VxMax * TurboVx)/valueWaterX;
            }
        }
    }
}
if (Key_D &amp;&amp; !A) { //Movimiento hacia la derecha
    if((place_meeting(x+1,y,C_obj)||place_meeting(x+1,y,Bounce_obj)) || ((place_meeting(x-1,y,C_obj) || place_meeting(x-1,y,Bounce_obj))&amp;&amp;(delay&lt;maxdelay)&amp;&amp;!(place_meeting(x,y+1,C_obj) || place_meeting(x,y+1,Bounce_obj)))){ //Si toco pared o Bounce por la izquierda o derecha, el delay no ha terminado y no tengo suelo debajo
        if ((place_meeting(x + 1, y, C_obj) || place_meeting(x + 1, y, Bounce_obj)) &amp;&amp; !(place_meeting(x, y+1, C_obj) || place_meeting(x, y+1, Bounce_obj)) &amp;&amp; !Scroll &amp;&amp; !place_meeting(x,y,water_obj)) { //Si toco pared a la derecha y no toco suelo ni hago scroll ni toco agua
            D = true;
            Vx = Vx + ax/valueWaterX;
            if (!Key_Shift) { //Sin turbo
                if (Vx &gt; VxMax/valueWaterX) {
                    Vx = VxMax/valueWaterX;
                }
            } else if (Key_Shift) { //Con turbo
            Vx = Vx + ax/valueWaterX;
                if (Vx &gt; (VxMax * TurboVx)/valueWaterX) {
                    Vx = VxMax * TurboVx/valueWaterX;
                }
            }
        } else if((place_meeting(x-1,y,C_obj) || place_meeting(x-1,y,Bounce_obj))&amp;&amp; Scroll){
            delay=delay+1;
            if (delay&gt;maxdelay){
                delay=maxdelay;
            }
        } else if ((place_meeting(x-1,y,C_obj) || place_meeting(x-1,y,Bounce_obj))&amp;&amp; !Scroll){
            D=true;
            Vx = Vx + ax/valueWaterX;
            if (!Key_Shift) { //Sin turbo
                if (Vx &gt; VxMax/valueWaterX) {
                    Vx = VxMax/valueWaterX;
                }
            } else if (Key_Shift) { //Con turbo
                Vx = Vx + ax/valueWaterX;
                if (Vx &gt; (VxMax * TurboVx)/valueWaterX) {
                    Vx = VxMax * TurboVx/valueWaterX;
                }
            }
        }
    } else {
        delay=0;
        D = true;
        Vx = Vx + ax/valueWaterX;
        if (!Key_Shift) { //Sin turbo
            if (Vx &gt; VxMax/valueWaterX) {
                Vx = VxMax/valueWaterX;
            }
        } else if (Key_Shift) { //Con turbo
            Vx = Vx + ax/valueWaterX;
            if (Vx &gt; (VxMax * TurboVx)/valueWaterX) {
                Vx = VxMax * TurboVx/valueWaterX;
            }
        }
    }
}
if (!Key_A &amp;&amp; !Key_D) { //Si suelto una tecla de movimiento
    if (WallJump) { //Inercia en caso de estar haciendo wall jump
        if (Vx &lt; 0) {
            Vx = (Vx + (ax / 15))/valueWaterX;
            if (Vx &gt; 0) {
                Vx = 0;
            }
        }
        if (Vx &gt; 0) {
            Vx = (Vx - (ax / 15))/valueWaterX;
            if (Vx &lt; 0) {
                Vx = 0;
            }
        }
    } else { //En el resto de casos reiniciar la velocidad
        Vx = 0;
    }
}
//SALTO
if (!place_meeting(x, y - 1, C_obj) &amp;&amp; !Bouncing) { //Si no toco techo
    if ((place_meeting(x, y + 1, C_obj) || place_meeting(x,y+1,Bounce_obj) || water)&amp;&amp; !Scroll) { //Salto normal
        if (Key_Space) {
            if (place_meeting(x + 1, y, C_obj) || place_meeting(x+1,y,Bounce_obj)) {
                if (!Key_D) {
                    Vy = JumpVy/valueWaterJump;
                    if (Vy &lt; (-VyMax)/valueWaterJump) {
                        Vy = -VyMax/valueWaterJump;
                    }
                }
            } else if (place_meeting(x - 1, y, C_obj) || place_meeting(x-1,y,Bounce_obj)) {
                if (!Key_A) {
                    Vy = JumpVy/valueWaterJump;
                    if (Vy &lt; (-VyMax)/valueWaterJump) {
                        Vy = -VyMax/valueWaterJump;
                    }
                }
            } else if (!(place_meeting(x + 1, y, C_obj)|| place_meeting(x+1,y,C_obj)) &amp;&amp; !(place_meeting(x - 1, y, C_obj)|| place_meeting(x-1,y,Bounce_obj))) {
                Vy = JumpVy/valueWaterJump;
                if (Vy &lt; (-VyMax)/valueWaterJump) {
                    Vy = -VyMax/valueWaterJump;
                }
            }
        }
    }
    if ((place_meeting(x + 1, y, C_obj) || place_meeting(x+1,y,Bounce_obj)) /*&amp;&amp; !(place_meeting(x, y + 1, C_obj) || place_meeting(x,y+1,Bounce_obj))*/&amp;&amp; (Scroll || Key_D)) { //Salto de pared derecho
        if (Key_Space) {
            WallJump = true;
            Scroll = false;
            delay=0;
            Vy = ScrollDownVy + WallJumpVy;
            Vx =-WallJumpVx;
            if (Vy &lt; (-VyMax)/valueWaterJump) {
                Vy = -VyMax/valueWaterJump;
            }
            if (Vx &lt; (-VxMax)/valueWaterJump) {
                Vx = -VxMax/valueWaterJump;
            }
        }
    }
    if ((place_meeting(x - 1, y, C_obj) || place_meeting(x-1,y,Bounce_obj)) /*&amp;&amp; !(place_meeting(x, y + 1, C_obj) || place_meeting(x,y+1,Bounce_obj))*/&amp;&amp; (Scroll || Key_A)) { //Salto de pared izquierda
        if (Key_Space) {
            WallJump = true;
            Scroll = false;
            delay=0;
            Vy = ScrollDownVy + WallJumpVy;
            Vx =WallJumpVx;
            if (Vy &lt; (-VyMax)/valueWaterJump) {
                Vy = -VyMax/valueWaterJump;
            }
            if (Vx &gt; VxMax)/valueWaterJump {
                Vx = VxMax/valueWaterJump;
            }
        }
    }
}
} else {
    if(Vx&lt;0){
        Vx=Vx+ax;
        if(Vx&gt;0){
            Vx=0;
        }
    } else if(Vx&gt;0){
        Vx=Vx-ax;
        if(Vx&lt;0){
            Vx=0;
        }
    }
}
//------------POSICIÓN SQUARE-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
x = x + Vx;
y = y + Vy;
Vxaux=Vx;
Vyaux=Vy;
//------------CONTROL DEL VECTOR DE LOS OJOS--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(!Scroll &amp;&amp; (A || D)){
    VxE=Vx;
} else if(!Scroll &amp;&amp; !A &amp;&amp; !D &amp;&amp; !WallJump){
    if(VxE&gt;0){
        VxE=VxE-ax*EAC;
        if(VxE&lt;0){
            VxE=0;
        }
    } else if(VxE&lt;0){
        VxE=VxE+ax*EAC;
        if(VxE&gt;0){
            VxE=0;
        }
    }
} else if(WallJump){
    VxE=Vx;
}
VyE=Vy;
//----------------------COLISIÓN--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y,C_obj)){ // Si colisiono con C_obj
    //move_snap(1,1);
    if((sqrt(Vy*Vy))&gt;=(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&gt;=Vx
        while(place_meeting(x,y,C_obj)){ // Mientras colisione
            y=y-Vy/(sqrt((Vy*Vy))); //Resto o sumo 1 dependiendo del signo del vector
            x=x-(Vx/sqrt(Vy*Vy)); //Desplazo la cantidad entre 0 y 1 píxeles correspondientes en x
        }
    } else if ((sqrt(Vy*Vy))&lt;(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&lt;Vx
        while(place_meeting(x,y,C_obj)){ // Mientras colisione
            x=x-Vx/sqrt((Vx*Vx)); //Resto o sumo 1 dependiendo del signo del vector
            y=y-(Vy/sqrt(Vx*Vx));//Desplazo la cantidad entre 0 y 1 píxeles correspondientes en y
        }
    }
    move_snap(1,1); // alineo a (1,1) para eliminar decimales
    if((place_meeting(x+1,y,C_obj) || place_meeting(x-1,y,C_obj)) &amp;&amp; !place_meeting(x,y+1,C_obj) &amp;&amp; !place_meeting(x,y-1,C_obj)){ // pared izquierda o derecha
        if(!place_meeting(x,y,water_obj)){
            Vy = ScrollDownVy;
            Scroll=true;
        }
        Vx = 0;
        WallJump = false;
    } else if (((place_meeting(x,y-1,C_obj) || place_meeting(x,y+1,C_obj))) &amp;&amp; (!(place_meeting(x+1,y,C_obj) || place_meeting(x-1,y,C_obj)) || Vx=0)){ //Suelo o techo
        Scroll=false;
        if(Vy&gt;=0){
            WallJump=false;
        }
        Vy=0;
    } else if ((place_meeting(x-1,y,C_obj) || place_meeting(x+1,y,C_obj)) &amp;&amp; ((place_meeting(x,y-1,C_obj) || place_meeting(x,y+1,C_obj)))){ //Esquina cerrada
        Vx=0;
        Vy=0;
        WallJump=false;
        Scroll=false;
        if(place_meeting(x,y-1,C_obj) &amp;&amp; !place_meeting(x,y+1,C_obj) &amp;&amp; !place_meeting(x,y,water_obj)){ //Si es una esquina cerrada alta
            Scroll=true;
            Vy=ScrollDownVy;
        }
    }
}
if(place_meeting(x,y,Bounce_obj)){ // Si colisiono con Bounce_obj
    if(!Bouncing){
        if((sqrt(Vy*Vy))&gt;=(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&gt;=Vx
            while(place_meeting(x,y,Bounce_obj)){ // Mientras colisione
                y=y-Vy/(sqrt((Vy*Vy))); //Resto o sumo 1 dependiendo del signo del vector
                x=x-(Vx/sqrt(Vy*Vy)); //Desplazo la cantidad entre 0 y 1 píxeles correspondientes en x
            }
        } else if ((sqrt(Vy*Vy))&lt;(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&lt;Vx
            while(place_meeting(x,y,Bounce_obj)){ // Mientras colisione
                x=x-Vx/sqrt((Vx*Vx)); //Resto o sumo 1 dependiendo del signo del vector
                y=y-(Vy/sqrt(Vx*Vx));//Desplazo la cantidad entre 0 y 1 píxeles correspondientes en y
            }
        }
    }
    move_snap(1,1); // alineo a (1,1) para eliminar decimales
    if((place_meeting(x+1,y,Bounce_obj) || place_meeting(x-1,y,Bounce_obj)) &amp;&amp; !place_meeting(x,y+1,Bounce_obj) &amp;&amp; !place_meeting(x,y-1,Bounce_obj)){ // pared izquierda o derecha
        if(!place_meeting(x,y,water_obj)){
            Vy = ScrollDownVy;
            Scroll=true;
        }
        Vx = 0;
        //WallJump = false;
    } else if (((place_meeting(x,y-1,Bounce_obj) || place_meeting(x,y+1,Bounce_obj))) &amp;&amp; (!(place_meeting(x+1,y,Bounce_obj) || place_meeting(x-1,y,Bounce_obj)) || Vx=0) &amp;&amp; !Bouncing){ //Suelo o techo
        Vy=0;
        Scroll=false;
        Bouncing=true;
        //WallJump=false;
    } else if ((place_meeting(x-1,y,Bounce_obj) || place_meeting(x+1,y,Bounce_obj)) &amp;&amp; ((place_meeting(x,y-1,Bounce_obj) || place_meeting(x,y+1,Bounce_obj)))&amp;&amp; !Bouncing){ //Esquina cerrada
        Vx=0;
        Vy=0;
        //WallJump=false;
        Scroll=false;
        Bouncing=true;
    }
}
if(!place_meeting(x,y+32,Bounce_obj)){
    Bouncing=false;
}
//------------ALGORITMO DE WATER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y,water_obj) &amp;&amp; !water){ //Entrar en agua
    posWater=0;
    water=true;
    Scroll=false;
    valueWaterX=cteWaterX;
    valueWaterY=cteWaterY;
    valueWaterJump=cteWaterJump;
    if(Burn){
        Burn=false;
        BurnTime=0;
        Eyes_obj.sprite_index=Eyes_spr;
        instance_destroy(Ash_obj);
    }
    for(i=0;place_meeting(x,y-i,water_obj);i++){
        posWater++;
    }
    if(!place_meeting(x-Vxaux,y-Vyaux,water_obj)){ // se crean las partículas de agua si en el frame anterior no estaba colsisionando con el agua
        for(i=0;i&lt;waterQuality;i++){
            instance_create(x+i*(sprite_height/waterQuality),y+(sprite_height-posWater),water_particle_obj);
        }
    }
} else if(!place_meeting(x,y,water_obj) &amp;&amp; water){ //salir de agua
    posWater=0;
    water=false;
    valueWaterX=1;
    valueWaterY=1;
    valueWaterJump=1;
    if(Vy&lt;0){
        Vy=JumpVy;
    }
    for(i=0;place_meeting(x,y-i,water_obj);i++){
        posWater++;
    }
    for(i=0;i&lt;waterQuality;i++){
        instance_create(x+i*(sprite_height/waterQuality),y+(sprite_height-posWater),water_particle_obj);
    }
}
//----------COLISIÓN DE FUEGO-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y,fire_particle_obj) &amp;&amp; !Burn &amp;&amp; !water){
    Burn=true;
    Eyes_obj.sprite_index=Eyes3_spr;
    instance_create(x,y,Ash_obj);
    Ash_obj.image_yscale=1/32;
}
//-----------CONTROLADOR DE LA VARIABLE SCROLL------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (!(place_meeting(x - 1, y, C_obj) || place_meeting(x-1,y,Bounce_obj)) &amp;&amp; !(place_meeting(x + 1, y, C_obj) || place_meeting(x+1,y,Bounce_obj))) {
    Scroll = false;
}
//-----------POSICIÓN OJOS--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(alive){
    if (Scroll){
        if(place_meeting(x-1,y,C_obj) || place_meeting(x-1,y,Bounce_obj)){
            VxE=VxE+ax*EAC;
            if(VxE&gt;(VxMax*TurboVx)){
                VxE=VxMax*TurboVx;
            }
        } else if(place_meeting(x+1,y,C_obj)|| place_meeting(x+1,y,Bounce_obj)){
            VxE=VxE-ax*EAC;
            if(VxE&lt;(-VxMax*TurboVx)){
                VxE=-VxMax*TurboVx;
            }
        }
    }
    Eyes_obj.x=(x+((EyesLimit/(VxMax*TurboVx))*VxE)+6);
    Eyes_obj.y=(y+(((EyesLimit+2)/VyMax)*VyE)+6);
}
//------------POSICIÓN SHADER-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(alive){
    SquareShader_obj.x=(x-((18/(VxMax*TurboVx))*Vx));
    SquareShader_obj.y=(y-((18/VyMax)*Vy));
}
//------------ALGORITMO DE BURN---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(Burn &amp;&amp; !water){
    for(j=0;j&lt;(32*BurnTime/MaxBurnTime);j=j+Division){
        for(i=0;i&lt;ParticlesPerStep;i++){
            instance_create(x+irandom(32),y+(32*BurnTime/MaxBurnTime)-j,Square_fire_particle_obj);
        }
    }
    Ash_obj.x=x;
    Ash_obj.y=y;
    Ash_obj.image_yscale=BurnTime/MaxBurnTime;
    BurnTime++;
}
}//llave que cierra el alive
//-----------FIN DEL CÓDIGO ALIVE-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (alive &amp;&amp; (place_meeting(x, y, Sawblade_obj)|| BurnTime=MaxBurnTime)) { //Colisión de sierra
    if(Burn){
        Ash_obj.image_alpha=0;
    }
    image_alpha=0;
    alive = false;
    r = irandom(5);
    instance_create(x,y,particle_obj);
    instance_create(x+8,y,particle_obj);
    instance_create(x+16,y,particle_obj);
    instance_create(x+24,y,particle_obj);
    instance_create(x,y+8,particle_obj);
    instance_create(x+8,y+8,particle_obj);
    instance_create(x+16,y+8,particle_obj);
    instance_create(x+24,y+8,particle_obj);
    instance_create(x,y+16,particle_obj);
    instance_create(x+8,y+16,particle_obj);
    instance_create(x+16,y+16,particle_obj);
    instance_create(x+24,y+16,particle_obj);
    instance_create(x,y+24,particle_obj);
    instance_create(x+8,y+24,particle_obj);
    instance_create(x+16,y+24,particle_obj);
    instance_create(x+24,y+24,particle_obj);
    instance_destroy(Eyes_obj);
    instance_destroy(SquareShader_obj);
    if(r == 0){
        audio_play_sound(snd_Laugh1, 10, false);
    }
    else if(r == 1){
        audio_play_sound(snd_Laugh2, 10, false);
    }
    else if (r == 2){
        audio_play_sound(snd_Laugh3, 10, false);
    }
    else if (r == 3){
        audio_play_sound(snd_Laugh4, 10, false);
    }
    else if (r == 4){
        audio_play_sound(snd_Laugh5, 10, false);
    }
    else if (r == 5){
        audio_play_sound(snd_Laugh6, 10, false);
    }
    if(!Transition1_obj.End){
        alarm_set(0,deathTime);
    }
    if(global.taken=true){
    instance_create(global.x0_coin,global.y0_coin,coin_obj);
    global.taken=false;
    }
    
}

//---------------------------------COLISIÓN COLECCIONABLE--------------------------
if(place_meeting(x,y,coin_obj)){
global.taken=true;
instance_destroy(coin_obj);
audio_play_sound(snd_coin,2,false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>r2 = irandom(5);
    if(r2 == 0){
        audio_play_sound(snd_Laugh1, 10, false);
    }
    else if(r2 == 1){
        audio_play_sound(snd_Laugh2, 10, false);
    }
    else if (r2 == 2){
        audio_play_sound(snd_Laugh3, 10, false);
    }
    else if (r2 == 3){
        audio_play_sound(snd_Laugh4, 10, false);
    }
    else if (r2 == 4){
        audio_play_sound(snd_Laugh5, 10, false);
    }
    else if (r2 == 5){
        audio_play_sound(snd_Laugh6, 10, false);
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//instance_destroy(particle_obj);
//Component y
Vy=0;
//ScrollDownVy=4.5;
//VyMax=30;
//ay=0.9;
Scroll=false;
//Component x
Vx=0;
//VxMax=10;
//ax=2;
//TurboVx=1.5;
A=false;
D=false;
//Jump
//JumpVy=-20.5;
//WallJumpVy=-24.5;
//WallJumpVx=9;
WallJump=false;
//Bounce=31;
Bouncing=false;
delay=0;
maxdelay=4;
//Controladores
alive = true;
shift_pressed=false;
//deathTime=60;
//Fire
Burn=false;
//Division=12;//aumento de j
BurnTime=0;
//MaxBurnTime=3*60;
//ParticlesPerStep=1;
//water
water=false;
//cteWaterX=5;
//cteWaterY=15;
//cteWaterJump=5;
valueWaterY=1;
valueWaterX=1;
valueWaterJump=1;
posWater=0;
//waterQuality=64;
//Eyes
instance_create(6,6, Eyes_obj);//Ojos Personaje
VxE=0;
VyE=0;
//EAC=1.2;//Eyes Aceleration Constant
//Shader
instance_create(x,y,SquareShader_obj);
x=Xo;
y=Yo;
image_alpha=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="73">
      <action>
        <libid>1</libid>
        <id>222</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_next_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
