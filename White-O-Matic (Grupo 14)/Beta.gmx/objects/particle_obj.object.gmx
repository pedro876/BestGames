<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>particle_spr</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();
//water
water=false;
cteWaterX=2.5;
cteWaterY=7.5;
valueWaterY=1;
valueWaterX=1;
//fin water
ending=false;
alarm_set(0,Square_obj.deathTime);
Ash=false;
PFVX=0.5; //Parent VX Factor
PFVY=0.1; //Parent VY Factor
if(place_meeting(x,y,Ash_obj)){
    Ash=true;
}
if(!Ash){
    image_blend = make_colour_rgb(0,0,0);
    Vx=Square_obj.Vx;
    Vy=Square_obj.Vy;
    VyMax=30;
    ax=0.04;
    frictionX=1.5-ax;
    ay=0.5;
    step=false;
    angleDegree=45;
    angleRadian=(angleDegree*pi)/180;
    BounceFactorX=0.6;
    BounceFactorY=0.4;
    BounceLimit=2;
    Bounce=Square_obj.Bounce/2;
}else if(Ash){
    image_blend = make_colour_rgb(128,128,128);
    Vx=PFVX*Square_obj.Vx;
    Vy=PFVY*Square_obj.Vy;
    ay=0.03+random(0.2)-0.1;
    ax=0.2+random(0.2);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ending</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>true</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!Ash){//Inicio del código !ash
//físicas
if(Vx&gt;0){
    Vx=Vx-ax;
    if(place_meeting(x,y+1,C_obj)){
        Vx=Vx-frictionX;
    }
    if(Vx&lt;0){
        Vx=0;
    }
} else if (Vx&lt;0){
    Vx=Vx+ax;
    if(place_meeting(x,y+1,C_obj)){
        Vx=Vx+frictionX;
    }
    if(Vx&gt;0){
        Vx=0;
    }
}
if(!place_meeting(x,y+1,C_obj) &amp;&amp; valueWaterY==1){
    Vy=Vy+ay;
    if (Vy&gt;VyMax){
        Vy=VyMax;
    }
} else if(!place_meeting(x,y-1,C_obj) &amp;&amp; valueWaterY&gt;1){
    Vy=Vy-ay;
    if (Vy&lt;-VyMax){
        Vy=-VyMax;
    }
}
//COLISION AGUA
if(place_meeting(x,y,water_obj)&amp;&amp; !water){ // entrar en agua
    valueWaterY*=cteWaterY;
    valueWaterX*=cteWaterX;
    water=true;
} else if(!place_meeting(x,y,water_obj)&amp;&amp; water){ // salir del agua
    valueWaterY=1;
    valueWaterX=1;
    water=false;
    Vy=Vy/cteWaterY;
}
//Posición
x=x+Vx/valueWaterX;
y=y+Vy/valueWaterY;
//Colisiones
//-------------------------COLISIÓN------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y,C_obj)){ // Si colisiona con C_obj o con Bounce_obj
    move_snap(1,1);
    if((sqrt(Vy*Vy))&gt;=(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&gt;=Vx
        while(place_meeting(x,y,C_obj)){ // Mientras colisione
            y=y-Vy/(sqrt((Vy*Vy))); //Resto o sumo 1 dependiendo del signo del vector
            x=x-(Vx/sqrt(Vy*Vy)); //Desplazo la cantidad entre 0 y 1 píxeles correspondientes en x
        }
    } else if ((sqrt(Vy*Vy))&lt;(sqrt(Vx*Vx))){ //Si en valor absoluto Vy&lt;Vx
        while(place_meeting(x,y,C_obj)){ // Mientras colisione
            x=x-Vx/sqrt((Vx*Vx)); //Resto o sumo 1 dependiendo del signo del vector
            y=y-(Vy/sqrt(Vx*Vx));//Desplazo la cantidad entre 0 y 1 píxeles correspondientes en y
        }
    }
    move_snap(1,1); // alineo a (1,1) para eliminar decimales
    if((place_meeting(x+1,y,C_obj) || place_meeting(x-1,y,C_obj)) &amp;&amp; !place_meeting(x,y+1,C_obj) &amp;&amp; !place_meeting(x,y-1,C_obj)){ // pared izquierda o derecha
        Vx = -BounceFactorX*Vx;
        if(Vx&lt;BounceLimit &amp;&amp; Vx&gt;-BounceLimit){
            Vx=0;
        }
    } else if (((place_meeting(x,y-1,C_obj) || place_meeting(x,y+1,C_obj))/* || (place_meeting(x,y-1,Bounce_obj) || place_meeting(x,y+1,Bounce_obj))*/) &amp;&amp; !(place_meeting(x+1,y,C_obj) || place_meeting(x-1,y,C_obj))){ //Suelo o techo
        Vy=-BounceFactorY*Vy;
        if(Vy&lt;BounceLimit &amp;&amp; Vy&gt;-BounceLimit){
            Vy=0;
        }
        if(place_meeting(x,y+1,Bounce_obj) &amp;&amp; !place_meeting(x,y-1,Bounce_obj)){
            Vy=-Bounce;
        } else if (place_meeting(x,y-1,Bounce_obj) &amp;&amp; !place_meeting(x,y+1,Bounce_obj)){
            Vy=Bounce;
        }
    } else if ((place_meeting(x-1,y,C_obj) || place_meeting(x+1,y,C_obj)) &amp;&amp; ((place_meeting(x,y-1,C_obj) || place_meeting(x,y+1,C_obj))/* || (place_meeting(x,y-1,Bounce_obj) || place_meeting(x,y+1,Bounce_obj))*/)){ //Esquina cerrada
        Vx = -BounceFactorX*Vx;
        if(Vx&lt;BounceLimit &amp;&amp; Vx&gt;-BounceLimit){
            Vx=0;
        }
        Vy=-BounceFactorY*Vy;
        if(Vy&lt;BounceLimit &amp;&amp; Vy&gt;-BounceLimit){
            Vy=0;
        }
        if (place_meeting(x,y-1,C_obj) &amp;&amp; !place_meeting(x,y+1,C_obj) &amp;&amp; place_meeting(x,y-1,Bounce_obj)){//Si es una esquina cerrada alta con rebote
            Vy=Bounce;
        } else if (place_meeting(x,y+1,C_obj) &amp;&amp; !place_meeting(x,y-1,C_obj) &amp;&amp; place_meeting(x,y-1,Bounce_obj)){//Si es una esquina cerrada baja con rebote
            Vy=-Bounce;
        }
    }
}
//-------------------------AJUSTE DEL BOUNCE---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y+1,Bounce_obj)){
    Vy=-Bounce;
}
//-------------------------COLISIÓN DE SIERRA--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y,Sawblade_obj) &amp;&amp; !step){ //Colisión de sierra (ángulo de dispersión)
    step=true;
    alpha=(random(angleDegree)*pi)/180;
    Vx=-(cos(alpha-angleRadian/2)*Vx-sin(alpha-angleRadian/2)*Vy);
    Vy=-0.9*(sin(alpha-angleRadian/2)*Vx+cos(alpha-angleRadian/2)*Vy);
    
}
if(!place_meeting(x,y,Sawblade_obj)){
    step=false;
}
//-------------------------AJUSTE DEL BOUNCE---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if(place_meeting(x,y+1,Bounce_obj)){
    Vy=-Bounce;
}
}//fin del código !ash
//=======================================================================================================================================================================================================================================
else if (Ash){ //Inicio del código ash
    Vx=Vx+ax;
    Vy=Vy+ay;
    x=x+Vx;
    y=y+Vy;
    if(place_meeting(x,y,water_obj) || place_meeting(x,y,C_obj)){
        instance_destroy(self);
    }
}//fin del código ash
if(ending &amp;&amp; image_alpha&gt;0){
    image_alpha-=1/Square_obj.deathTime;
    if(image_alpha&lt;=0){
        instance_destroy(self);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
